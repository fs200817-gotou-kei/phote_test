■環境構築
・基本的にFlutterはChromeとFlutter SDKあればできそうだね(もし無理ならAndroid Studioも)
・VSCODEでFlutterやつインストールする
・Chrome上でホットリロードするにはVSCODEのステータスバーを表示させ(コマンドパレットでtoggle status)、
　実行とかのマークがついているボタンを押してFlutterをChromeから起動させる

　

その他メモ
・runtimeExceptionクラスはjavaの処理中において処理をスローできる例外のスーパークラスのこと
・responseentity.okはstatusをokにしたレスポンス返す
→エラー出たときはデフォのExceptionが動いて自動でスローされて結果返しているっぽい
・コンソールは「〇〇の○○を○○する」("RelationControllerの見積全取得処理を開始")
・serviceがバッファになって型とかを統一化するイメージかな？
・何もしてないと多分responseEntityのようなヘッダー情報とかはなくてdataだけだと思う。
→多分クライアントのデフォの機能としてヘッダー情報とかを親切に載せてくれてるだけだと思う
→jpaは無駄にいじる必要がないと思うしそういうクラスじゃないのでserviceで例外の種類を判定し書き換えのロジックを組む必要がありそう
・flutter側では基本的にserviceで例外などのロジックを組んでいく
・springは空のコンストラクタ作らないと起動しない場合があるのを気を付ける
・確かにfrontでもmodelっているね。ないとvueでやったように各自でオブジェクト型を定義する必要があり面倒だし足りているか保証ができない
・factoryは簡単に言うとインスタンスを渡すメソッドのこと。
→newとの違いはクライアントからの共通のインターフェース(呼び出し方)で
　引数の種類や型などによってreturnする実装インスタンスを分岐できたりする仕組み
・statefulとかに値を渡す際はstateからはwidget.nameで取り出せる
・ScaffoldStateオブジェクトからSnackBar表示ができる(おそらくプロパティとして持っていてtrueとかにして引数渡すと引数を表示してくれる仕組み)
・Scaffoldのオブジェクトを
・Futureとは非同期処理の結果を返してくれるクラス、Futureが呼び出された時点でそのメソッドの非同期処理が始まる
→FutureBuilderはあくまでウィジェットであって、futureとbuilderが非同期処理の内部
→futureは型がFutureの関数や変数を指定する、builderは非同期処理の処理過程によって打仕分けしたいwidgetについて記載
　→futureの第二引数のsnapshotに関数の戻り値や処理状態などがわかる
・varは何回でも代入が可能、daynamicは初期化した後に別の型の値を入れるなど型を動的に変化させることができる
・finalは代入が1回のみ可能、初期化なしで宣言後に入れることはできない
・constはコンパイル時に値が確実に決まるfinal。finalはList型とかなら追加とかできるがconstはできない
・apiから取得後はjsonで参照型になっているからその参照型の内部の値を変えてそのままsetStateしても
　アドレス自体は変化ないからsetState時に更新が走らない、値のみを渡すと値渡しとなり変化があったと認識してレンダー再レンダーされる
・DataTableはカラムは抜けがあるとエラー出る、あとrowsを設定していないと、rowsは空でいいからそこだけは記載しておく必要がある
・fetchしたらjson加工が必要
・iconはymlで有効にしてから後はchildないとかでIconを使っていくだけ(https://api.flutter.dev/flutter/material/Icons-class.html)
・servieceクラスの使いかた
→サービス側はclass作って後はその中にメソッドを作っていくだけ(必要ならプロパティ定義)
→呼び出す側も他言語と同様メソッドである必要がありそう
　→メソッドはflutter使っているクラスでもメソッドを普通に定義すれいいのか
　→発火のタイミングを一覧で出してそれから疑問点を出す必要がある
　　→初期化時、ボタンクリック時
・名前付き引数もある
→受け取りメソッド側は{}で引数を設定し、呼び出し側はメソッド側の引数名を指定してval1: 1みたいにmapで送ると認識してくれる
・メソッドの引数設定には必須引数と任意で設定ができる(引数が絶対いる設定とどっちでもOKの設定)
・ルーティングはmain.dartにroutesを加えることでできるようになる
・ポート番号はプロジェクトのルートディレクトにある.vscodeフォルダ内のlaunch.jsonの中でconfigurationsのdartの下に"args": ["-d","chrome","--web-port","8000"],を追加する(ctr+F5)
・appbarはpreferredSizeWidgetを使用しているため値にはそれと同じ型の値を入れる必要がある
→なのでappbarのカスタムクラスを作るならそのクラスを継承する必要がある(sizeの部分をoverrideする)←そのそもサイズいじるクラス
・SourceTree使えるか？
・この前の要望は今回やってもらえるか
・パッケージ名は自分のHPとか持っていれば下記のようにする
com(jp).kboy.flutter-app
みたいにドメイン、homehgアドレス、アプリ名みたいにする
・Scaffoldなど中身を見ると渡せるプロパティの一覧が並んでいる
・バリデーションって言ったら大体、空白チェック、文字数、数字チェックになる(その他特殊文字とか、数字禁止とか)

■試験までの目標
・試験時には実装内容についてはほぼすべて理解している感じにしておく
→試験時には引き出しをどう使っていくかを考えたり実装したりすることに集中。

■昨日todo
OK・予定立てる
OK・flutterのある程度の使いかた把握

■今日todo(画面はテストのやつを参考にする)
OK・前回テストの画面軽く作成
OK・URL設定
→flutter_web_plugins使ってシャープ消す、flutter run -d chrome --web-port 8080で実行
　→本番ではスクリプトでサーバー上で実行する感じになるからコマンドでいいはず
OK・試験メモ内容確認
OK・ルーティング
OK・serviceクラス作成(apiからデータ取得)
OK・簡単なtable作成
・component共通化(apiのデータを表示するのをやってみよう、テストのようにカラム数違うやつも共通化)
・DB値表示(リレーションの値)
・crud
OK・簡単なバリデーション
→値を渡してfalseかどうかの結果を変えすでいいかな？ただどういうエラーは不明になってしまう
→スペースってnullチェックに引っかかるのか
OK・非同期
OK・アイコンなど設置
・結構ライブラリとか備わっている機能を使えてないってことが多いみたいだから気を付ける
・画面装飾(割と細かいところまでやっていく)
・androidエミュレーター動かない
・リダイレクト
・springリレーション
・frontでリレーションを使ってidからnameを取り出す
・カスタムバリデーション
・api使ってみる(https://www.sejuku.net/blog/7278)
・可読性は考えてないわけないけど読みやすさが足りてない
・printで細かくやっているのはいい、リリース時にコンソールを無効にできる仕組みを作るとよりいい
→ifでisTestとかでやったほうがいいかもね、そうすれば一括でリリース用はfalseにすればコンソール表示しないようにできる
→flutterの場合はdebugのフラグ使えるなら使う
・一般的なコーディングルールではコメントを書いたほうがいい
→コメントでは処理を書くのではなくて意図を書く
→メソッドの入出力(メソッドが何をやっているか、何を返してくれるか、概要把握するうえで)
・サーバー側とフロント側でちょいちょい抜けがあって、コードを返すようにする(エラーコード：エラー内容)
・自分のコードの理解力
・gitコミッ斗は戻したい位置って観点でいいか？適切なタイミングとは
・フレームワークの機能の@を使ってリレーションをやったほうがよかった
・webエラーのハンドリング(500エラーが出ないようにする)
→200で返してその中身がエラー
→あらかじめ想定できるものは200
→エラーコードを定義してそれを200で返す
→想定できるのは200で返すがエラーコード定義しておく
→想定できないものは500でいい
→ユーザーに分かりやすく伝えるのが仕事

■todo
OK・crudの構文とか理解
OK・apiでリレーション試してみる
・api例外処理(ないIDとかだった場合とか200で返す)
　①mysqlとのセッションがない
　②リソースがない
　③URLが間違っている
・flutter側でserviceを使って例外処理
・お手本見ずにcrud再度作ってみる
・frontでリレーション試すためfkからname取り出してみる




OK・サーチウィジェットでserviceを呼び出せるようにする
OK・サービスクラスから値が返ってくるようにする
OK・型がおかしいからjsonとかに変換する

・githubのお手本見ながらapi取得から表示までの流れをやってみる

